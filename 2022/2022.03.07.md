# 프로토콜은...
21.03.07

mood: 😤 ☺️

<! 공부하며 작성한 내용이며 틀린 내용이 있을 수 있습니다. >

## 오늘 한 것
- 사파리와 STEP3 진행 
- 프로토콜과 delegate 세션 진행

---


## 학습 내용
### protocol
프로토콜은 클래스, 구조체 또는 열거형에 꼭 지켜야 할 사항들을 알려주는 메뉴얼 같은 것이다.

```swift
protocol Speakerable {
    func speak()
}
```

내부에 어떤 프로퍼티가 필요한지 어떤 메서드가 필요한지 정해 줄 수 있다. 

정해주되, 내부에 자세한 구현은 해줄 필요는 없다.

프로퍼티의 경우 이름, 메서드의 경우 이름과 파라미터를 가지고 구분한다. 

 

```swift
struct Person: Speakerable {
    func speak() {
        print("안녕하세요")
    }
}

class Animal: Speakerable {
    func speak() {
        print("월월월")
    }
}

enum Gaget: Speakerable {
    func speak() {
        print("삐릿삐릿")
    }
}
```

이런식으로 상속을 해주는 것과 같은 방식으로 프로토콜을 채택해주면 된다. 

(그렇지만 절대 상속이 아니다. 상속과는 다르다.) 

Speakable 프로토콜을 채택한 객체들은 어떤 타입이든지에 상관없이, speak 해 줄 것을 보장해 준다. 

#### 프로토콜의 프로퍼티 요구사항

- 프로퍼티의 이름과 타입이 필요하다.
- gettable 인지 settable 인지 정해주어야 한다.
- 저장 프로퍼티인지 연산 프로퍼티인지는 설정해 줄 필요 없다. 
(채택하고 구현하는 과정에서 알아서 하면 된다.)
- 타입 프로퍼티인 경우 static 을 붙인다.
- var 로만 선언할 수 있다.

```swift
protocol Employee {
    var company: String { get }
}
```

#### 프로토콜의 메서드 요구사항

- 메서드의 이름과 파라미터들의 이름 타입 (있다면) 반환값과 타입이 필요하다. 
(이름이 같고 파라미터가 달라도 다른 함수로 인식한다.)
- 메서드 내부에서 프로퍼티의 값을 변경하는 메서드를 만들땐 ‘mutating’ 키워드를 붙여준다. (클래스에서 이를 구현할 땐 mutating 키워드를 빼면 된다.)

```swift
protocol Eatable {
    func eat(food: String)
}
```

#### 프로토콜의 초기화 구문 요구사항

프로토콜에서는 초기화 구문도 지정해 줄수 있다. 

- 일반적인 초기화 구문과 같은 방식으로 작성하면 된다. (구현하진 않고)
- 클래스, 구조체, 열거형에서 프로토콜을 준수하려고 초기화 구문을 작성하면 required 키워드를 앞에 붙여주면 된다. 
(final 키워드 일 경우에는 붙여줄 필요 없다.)
- 실패가능한 초기화 구문도 요구할 수 있다.

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}

class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```

#### 타입으로써 프로토콜

"T가 프로토콜을 준수하는 타입 T가 존재한다" 라는 구절에서 비롯된 *존재 타입 (existential type)* 이라고 한다. 

이라고 공식문서에 쓰여있다. 

프로토콜은 빈 깡통이지만, 우리는 이것을 하나의 타입 처럼 사용해 줄 수 있다. 

```swift
var speakers: [Speakerable]
```

Speakable 이라는 프로토콜을 준수하는 speakers 라는 배열 변수를 만들었다. 

그럼 speaker 안에는 어떤 값이 들어갈 수 있을까? 

Person도 Animal도 Gaget도 들어올 수 있다. 

3개 모두 Speakable이라는 프로토콜을 준수하고 있기 때문이다. 

이런 식으로 특정한 타입이 아니라, 특정한 프로토콜을 준수하는 어떤 타입을 받고 싶을 경우 사용할 수 있다.
---



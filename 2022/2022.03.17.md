# 🌳 자료구조의 종류 🌳
21.03.17

mood: 🤔

<! 공부하며 작성한 내용이며 틀린 내용이 있을 수 있습니다. >

## 오늘 한 것
- SOLID 세션 듣고 학습활동  
- 자료구조 공부 
- subscript 공부 

## 문제점 / 고민한점
- 한 객체가 subscript 타입을 2개 가질 수 있을까? 
- swift는 왜 String.Index 타입을 만들었을까?   

---

## 학습 내용
### 자료구조의 종류
![](https://i.imgur.com/c5rhhLJ.jpg)

#### 🍽 Stack 스택
스택은 First In Last Out 을 지키는 자료구조이다. 
바구니나, 쌓여진 접시를 생각하면 된다. 가장 나중에 놓인 값을 먼저 빼야 한다. 

삽입과 마지막 값 제거는 O(1)이라고 볼 수 있다. 한번에 가능
중간이나 앞에서 값을 삽입 하거나 제거하려고 하면 공간을 만들어 주거나 공간을 메꿔 주어야 하기 때문에 시간 복잡도가 증가한다.

swift 에서 제공해주는 배열이 stack 형태로 구현되어 있다. 

#### 🏁 Queue 큐
큐는 First In First Out 을 지키는 자료구조이다. 
식당 앞에 서 있는 줄을 생각하면 된다. 먼저 줄 서있는 사람이 먼저 밥을 먹는다. 

삽입과 첫번째 값 제거는 O(1)이라고 볼 수 있다.

swift 는 큐를 지원하지 않는다.

> 우선 큐와 스택은 정렬이 되어 있는가? 어떤 방식으로 검색할 것인가에 따라서 검색 시간 복잡도가 아주 차이가 난다.

#### 🗄 Hash Table 해시 테이블
특정한 key 값을 가지고 value를 찾는 방식이다.
고유한 key 를 저장하고, hash 함수를 이용해서 암호화 한다. 암호로 만들어놓은 메모리에 value 를 저장해 놓는다.
hash 함수는 보통 O(1) 단 한번의 경우로 찾을 수 있다.
물론 hash 함수를 구현하다 보면, 충돌하는 경우도 생기고 하는데 이런 것들을 피해서 hash 함수를 잘 구현하는 것이 hash table의 성능을 높이는데 도움이 된다. 

swift 에서는 dictionary 가 hash table 형태로 구현 되어있다. 

> hash 테이블에서는 순서를 가질 수가 없다는 치명적인 단점이 있다. 하지만 삽입, 제거 모두 아주 빠르고 key 값을 알고 있다면 검색도 아주 빠르다. 

**노드 기반 자료 구조**
위의 자료구조들은 자료구조를 만들기 시작하면 어느 정도의 연결된 메모리를 가지고 구조를 만들었다. 
노드를 이용하면 메모리 여기 저기의 떨어져 있는 정보들을 한 구조로 엮어서 사용할 수 있다. 

노드는 값과 다른 노드와 연결되는 주소 값을 가지고 있는 아이다. 

#### 🔗 Linked List 연결 리스트
연결리스트는 그림과 같이 노드로 값이 연결되어 있는 자료구조 형태이다. 

연결된 노드들에서 첫번째 노드를 Head 마지막 노드를 tail 이라고 부른다. 

연결리스트가 배열과 비교해서 가지는 장점은 삽입과 삭제의 시간이 덜 들어간다는 것이다. 
스택이나 큐는 메모리가 연결 되어 있기 때문에 삽입시 공간을 만들어 주어야 하고 삭제시 공간을 메꿔주어야 한다. 이 과정에서 메모리들이 하나씩 이동하는 일이 발생한다. 

하지만 연결리스트는 그저 새롭게 연결을 해주기만 하면 된다! 이것이 연결 리스트를 쓰는 가장 큰 이유다 

**양방향 연결 리스트**
주소가 양쪽으로 연결 되어 있는 연결 리스트 
**원형 연결 리스트**
head 와 tail 이 연결되어 있는 연결 리스트 

등의 다양한 연결 리스트 들이 있다. 

#### 🌳 Tree
노드로 이루어진 자료구조 이며, 위의 그림 처럼 연결되어 있는 것을 볼 수 있다. 
가장 상위의 노드를 root 라고 한다.
root를 출발로 클래스에서의 상속을 표현할때 처럼 👩‍👧‍👦부모 자식 관계로 연결 되어 있는 노드를 나타낸다.

모든 노드에서 하위 트리의 노드의 개수가 같으면 balanced 균형 트리 라고 한다. 
아닐 경우에는 imbalanced 불균형 트리 라고 한다.

**🌴 이진 탐색 트리**
이진 탐색 트리는 
탐색을 빠르게 하기 위해서 트리에서 규칙을 추가해 놓은 트리이다. 

규칙 
1. 각 노드의 자식은 왼쪽에 하나, 오른쪽에 하나 가 최대이다. 
2. 한 노드의 왼쪽 자식에는 자신 보다 작은 값, 오른쪽 자식에는 자신 보다 큰 값만 올 수 있다. 

이렇게 될 경우 검색에는 O(logN)이 든다. 
이진 검색을 편하게 하기 위해 만들어 놓은 것 같은 느낌을 개인적으로 받았다. 

삽입 전에는 검색을 시행해야하고(정렬된 트리이기 때문에) 삽입을 하는 단계는 한단계 이다. 
그래서 삽입은 검색과 똑같은 O(logN)이다. 

> 정렬된 배열과 비교 했을 때, 정렬된 배열은 검색에 O(logN), 삽입에 O(N), 삭제에 O(N)이 걸리는데 트리는 셋다 O(logN) 이기 때문에 트리가 더 빠르다. 
> 정렬된 값이 필요하고 검색, 삽입, 삭제가 자주 일어나면 트리는 좋은 선택이다.

### SOLID 세션을 듣고나서 
하나의 행동과 하나의 책임은 다른 것이다. 
delegate 는 추상화 타입을 의존한 예시라고 할 수 있다. 
 
 
---
우선순위 큐
우선순위 힙
트라이 
그래프 

에 라는 자료구조도 더 공부해야 할 것 같다. 

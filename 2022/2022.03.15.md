# 빅오는 완벽하지 않다
21.03.15

mood: 🥱 😐

<! 공부하며 작성한 내용이며 틀린 내용이 있을 수 있습니다. >

## 오늘 한 것
- Step1 PR
- 자료구조 공부

## 문제점 / 고민한점
- protocol 에서 Equtable 을 채택하는 방법 
- private 코드를 Unit test 에서 검사하는 방법 

---

## 학습 내용
### 빅 오 표기법 무엇일까?

우리는 자료구조와 알고리즘에 대해서 몇 단계를 걸쳐서 이 알고리즘이 작동하고 있는지를 알아보고 시간 복잡도를 측정한다. 그런데 이 단계라는 것이 항상 일정한 것이 아니라 조건에 따라서 변경 되기도 하는 등 다양하다.

그래서 이러한 개념을 형식화 해서 표현한 것을 빅오 표기법 이라고 한다. 

#### O(1)
**어떤 조건이 있든 항상 일정한 단계를 가지는 알고리즘의 시간 복잡도를 나타낸다.** 

만약에 배열에 새로운 값을 넣는다고 하자. 배열의 값이 1개이든, 2이든, 100개 이든 배열안의 값을 넣는 것에는 한단계 밖에 들지 않는다. 

빅오 중에 가장 빠른 알고리즘 유형이라고 말하며 상수 시간을 갖는 알고리즘 이라고 하기도 한다. 

(그렇다고 여기서 괄호 사이의 1이라는 것은 항상 일정한 단계가 소요된다는 것이지 1단계 밖에 소요되지 않는다는 뜻은 아니다.)

#### O(n)
**데이터 원소의 개수가 N 개 일때, N 개의 단계를 가지는 알고리즘의 시간 복잡도를 나타낸다.** 

대표적으로 선형 검색이 O(n) 알고리즘 이다. 

➡ 선형검색 - 컴퓨터가 한 셀씩 값을 검사하면서 값을 찾는 알고리즘 

#### O(logN)
**데이터가 2배로 증가할 때마다 한 단계씩 늘어나는 알고리즘의 시간 복잡도를 나타낸다.** 

대표적으로는 이진 검색 알고리즘이 있다. 

2️⃣ 이진 검색 - 100 중에 랜덤한 숫자를 맞춘다고 했을 때, 50을 부르고 그보다 작으면 25 크면 75를 불러서 점점 타겟을 좁혀 나가는 방식의 검색 

> **로가리즘**
> logN에서 나오는 로그는 로가리즘에서 따온 것이다. 
> 로가리즘은 지수의 반대되는 개념이다. 
> 2의 3 제곱이 2 * 2 * 2 = 8 을 나타낸 것 처럼 
> Log₂8 = 3 이다. 

#### **O(N²)**

데이터가 증가 할 때마다 N² 단계가 늘어나는 알고리즘의 시간 복잡도를 나타낸다. 

아주 느린 알고리즘이라고 할 수 있다. 이차 시간이라고도 부른다. 

대표적으로 버블 정렬, 선택정렬이 있다. 주로 오름차순이나 내림 차순으로 정렬할 때 사용하는 알고리즘이다. 

💭 버블 정렬

1. 오름 차순일 경우 pointer 를 첫번째 값과 두번째에 두고 두 값을 비교한다. 
2. 더 큰 값이 뒤에 오도록 위치를 바꾸거나 그대로 둔다. 포인트를 한단계 이동한다. 
3. point 가 마지막 셀 까지 도달한다. 서로 바뀌지 않을 때까지 단계를 계속한다. 

✅ 선택 정렬 

1. 데이터를 하나씩 확인하면서, 가장 작은 값을 찾고 그 인덱스를 저장한다
2. 가장 처음 값과 그 작은 값을 교환한다. 
3. 모든 값이 정렬 될 때까지 반복한다. 

#### 최악의 시나리오

위에서 선형 검색이 대표적인 O(n)알고리즘 이라는 이야기를 했다. 

그런데 실제로 코드를 돌려보았을 때, 찾아야 하는 값을 한번 만에 찾을 수도 있다. 이 경우에는 O(1)에 가깝다. 

그런데도 왜 사람들은 선형 검색이 대표적인 O(n)알고리즘이라고 말할까?

빅오 표기법은 일반적으로는 최악의 시나리오를 생각한다. 

그래서 선형검색에서 최악의 상황일 경우 O(n) 알고리즘이라고 이야기 하는 것이다. 

#### 빅오가 완벽한 표현법이 아니다.

빅오 표기법은 알고리즘에 따른 시간 분석도를 단순하게, 축약해서 표기한 것일 뿐이다. 

카테고리가 달라짐에 따라서 데이터를 얼마나 처리하냐에 따라서 아주 달라질 수 있다. 

심지어 같은 O(1) 인데도 단계의 차이가 많이 나는 것도 가능하다. 

예를 들어 선택 정렬과 버블 정렬이 있다. 둘다 대표적인 **O(N²) 이지만** 

실제로 같은 배열을 두 정렬로 비교해 보면 선택정렬이 2배 정도 빠른 것을 알 수 있다. 

그러기에 빅 오 표현법으로 비교를 하려고 한다면 잘 해야 한다. 

#### 비교를 할 땐 평균적인 시나리오도 고려해야 한다.

아까 빅오는 최악의 시나리오를 본다고 이야기 했다.

그러나, 평균적인 시나리오도 계산해서 비교할 줄 알아야 한다. 

항상 최악의 경우가 일어나라는 법은 없다. 보통은 평균적인 경우가 일어나기 마련이다. 

최악의 시나리오로 두가지 빅오를 비교했을 때에는 차이가 났는데 막상 평균적인 경우를 비교하면 아주 비슷한 결과가 나오는 경우도 있다.

그러니 빅오로 비교를 해서 고를 땐 여러가지를 판단해 비교할 줄 아는 능력이 중요하다.

---
짝궁이랑 같이 프로젝트를 하다가 혼자 프로젝트를 하니까 몇배는 더 어려운 것 같다. 
내 코드에 내 스스로 책임을 질 수 있도록 코드를 열심히 짜야겠다. 